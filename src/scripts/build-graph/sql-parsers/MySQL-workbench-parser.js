/**
 * Created by Sebastien on 9/1/2015.
 * Parses the SQL dumpfile generated by MySQL workbench reverse-engineering process
 */
module.exports = function(file) {
    var fs = require("fs"),
        lines = fs.readFileSync(file, "utf8").replace(/\r/g, "").replace(/\n */g, "\n").split("\n").filter(function(l) {
            return !/^\-\-/.test(l);
        }),
        graph = {};

    function parseConstraints(lines) {
        var lL = lines.length,
            localTable,
            localField,
            foreignTable,
            foreignField,
            alias,
            line,
            refStart = 0,
            refCount = 0,
            x;

        function getCount(i, tableName) {
            var count = 0,
                temp;

            while (!/^CREATE TABLE/.test(lines[i]) && i < lines.length) {
                temp = /\.?`([a-zA-Z0-9_\-]*)`(?!\.)(?!\))/.exec(lines[i]);
                if (temp && temp[1] === tableName) {
                    count++;
                }
                i++;
            }
            return count;
        }

        for (x = 0; x < lL; x++) {
            line = lines[x];
            refCount = 0;

            // get the table name
            if (/^CREATE TABLE/.test(line)) {
                refStart = x + 1;
                // store the table name
                localTable = /\.?`([a-zA-Z0-9_\-]*)`(?!\.)(?!\))/.exec(line)[1];
            }

            // get the relation alias
            if (/^CONSTRAINT/.test(line)) {
                // store local field name
                alias = /\.?`([a-zA-Z0-9_\-]*)`(?!\.)(?!\))/.exec(line)[1];
            }

            // get the localField
            if (/^FOREIGN KEY/.test(line)) {
                // store local field name
                localField = /\(`([a-zA-Z0-9_-]*)`\)/.exec(line)[1];
            }

            // get foreign info
            if (/^REFERENCES/.test(line)) {
                foreignTable = /\.?`([a-zA-Z0-9_\-]*)`(?!\.)(?!\))/.exec(line)[1];
                foreignField = /\(`([a-zA-Z0-9_-]*)`\)/.exec(line)[1];

                // determine extends
                if (localField === graph[localTable].primary) {
                    graph[localTable].extends = {
                        table: foreignTable,
                        local: localField,
                        foreign: foreignField
                    };
                } else {
                    // is an aggregation

                    // local
                    // make sure aggregates exists
                    if (!graph[localTable].aggregates) {
                        // graph[localTable].aggregates = {};
                        graph[localTable].aggregates = [];
                    }

                    refCount = getCount(refStart, foreignTable);
                    // add new aggregate config
                    graph[localTable].aggregates.push({
                        foreignTable: foreignTable,
                        localField: localField,
                        alias: buildConstraintName(alias, localTable, foreignTable, "single", localField, foreignField, refCount),
                        foreignField: foreignField,
                        cardinality: "single"
                    });

                    // foreign
                    // make sure aggregates exists
                    if (!graph[foreignTable].aggregates) {
                        graph[foreignTable].aggregates = [];
                    }

                    // add new aggregate config
                    graph[foreignTable].aggregates.push({
                        foreignTable: localTable,
                        localField: foreignField,
                        alias: buildConstraintName(alias, foreignTable, localTable, "many", foreignField, localField, refCount),
                        foreignField: localField,
                        cardinality: "many"
                    });
                }
            }
        }
    }

    function parseTables(lines) {
        var lL = lines.length,
            tableName,
            primaryField,
            fieldName,
            allowNull,
            defaultValue,
            dataType,
            line,
            j;

        for (j = 0; j < lL; j++) {
            line = lines[j];

            /******************************
             look for table creation line
             *****************************/
            if (/^CREATE TABLE/.test(line)) {
                // store the table name
                tableName = /\.?`([a-zA-Z0-9_\-]*)`(?!\.)(?!\))/.exec(line)[1];

                // create the table object
                graph[tableName] = {
                    fields: {}
                };
            }

            /******************************
             look for primary key line
             *****************************/
            if (/^PRIMARY KEY/.test(line)) {
                // keep working with current table & inject it's primary key reference
                primaryField = /\(`([a-zA-Z0-9_-]*)`\)/.exec(line)[1];
                graph[tableName].primary = primaryField;
            }

            /******************************
             look for fields
             *****************************/
            if (/^`/.test(line)) {
                // store the field name and create the field object
                fieldName = /^`([a-zA-Z0-9_-]*)`/.exec(line)[1];
                graph[tableName].fields[fieldName] = {};

                // add the allow_null property
                allowNull = !/NOT NULL/.test(line);
                graph[tableName].fields[fieldName].allowNull = allowNull;

                // determine dataType
                dataType = determineDataType(/(?:`[^`].*`) ([a-zA-Z\(\)0-9]*) /.exec(line)[1]);
                graph[tableName].fields[fieldName].dataType = dataType;

                // add default_value, if present
                if (/DEFAULT/.test(line)) {
                    defaultValue = /DEFAULT '?(.*)\b'{1} |DEFAULT '?(.*)\b'?|DEFAULT '()'/.exec(line)[1];

                    // determine default type
                    if (defaultValue === "NULL") {
                        defaultValue = null;
                    } else if (dataType === "integer") {
                        defaultValue = parseInt(defaultValue, 10);
                    } else if (dataType === "float") {
                        defaultValue = parseFloat(defaultValue);
                    }

                    graph[tableName].fields[fieldName].defaultValue = defaultValue;
                } else {
                    if (allowNull) {
                        graph[tableName].fields[fieldName].defaultValue = null;
                    }
                }

                // determine if writable
                graph[tableName].fields[fieldName].writable = !/AUTO_INCREMENT/.test(line);
            }
        }
    }

    function determineDataType(type) {
        type = type.replace(/\([0-9]*\)/, "").toLowerCase();
        switch (type) {
            case "char":
            case "varchar":
            case "tinytext":
            case "text":
            case "mediumtext":
            case "longtext":
            case "tinyblob":
            case "blob":
            case "mediumblob":
            case "longblob": {
                type = "string";
                break;
            }
            case "date": {
                type = "date";
                break;
            }
            case "time": {
                type = "time";
                break;
            }
            case "timestamp":
            case "datetime": {
                type = "datetime";
                break;
            }
            case "float":
            case "decimal":
            case "numeric": {
                type = "float";
                break;
            }
            case "tinyint":
            case "smallint":
            case "mediumint":
            case "int":
            case "integer":
            case "bigint": {
                type = "integer";
                break;
            }
            default: {
                throw new Error("Unknown database type: " + type);
            }
        }

        return type;
    }

    function pluralize(s) {
        if (!s) {
            return s;
        }
        // exception case compound word using "history"
        if (/[hH]istory$/.test(s)) {
            return s;
        } else if (/[sx]$/.test(s)) {
            s += "es";
        } else if (/y$/.test(s)) {
            s = s.substr(0, s.length - 1) + "ies";
        } else {
            s += "s";
        }

        return s;
    }

    function singularize(s) {
        var length = s.length,
            lastThree = s.substr(length - 3, length),
            lastTwo = s.substr(length - 2, length),
            last = s.charAt(length - 1);

        // ends with ies
        if (lastThree === "ies") {
            s = s.substr(0, s.length - 3) + "y";
        } else if (lastThree === "ses") {
            s = s.substr(0, s.length - 2);
        } else if (lastTwo === "us" || lastTwo === "ss" || last !== "s") {
            s = s;
        } else {
            s = s.substr(0, length - 1);
        }

        return s;
    }

    function stringStartsWith(str, substr, from) {
        from = from || 0;
        return str.indexOf(substr, from) === from;
    }

    function stringEndsWith(str, substr, from) {
        if (from === undefined || from > str.length) {
            from = str.length;
        }

        from -= substr.length;
        return str.indexOf(substr, from) !== -1 && str.indexOf(substr, from) === from;
    }

    function partify(str) {
        /*jshint loopfunc:true */
        var parts = [str],
            i,
            j,
            hasUnderscores = /_/.test(str),
            hasDashes = /\-/.test(str),
            hasUpperCase = /[A-Z]/.test(str);

        if (/ /.test(str)) {
            throw Error("string can't contain spaces");
        }

        if (hasDashes) {
            for (i = 0; i < parts.length; i++) {
                j = i;
                if (/\-/.test(parts[i])) {
                    parts.splice(i, 1)[0].split("-").forEach(function(p) {
                        parts.splice(j, 0, p);
                        j++;
                    });
                }
            }
        }

        if (hasUnderscores) {
            for (i = 0; i < parts.length; i++) {
                j = i;
                if (/_/.test(parts[i])) {
                    parts.splice(i, 1)[0].split("_").forEach(function(p) {
                        parts.splice(j, 0, p);
                        j++;
                    });
                }
            }
        }

        if (hasUpperCase) {
            for (i = 0; i < parts.length; i++) {
                j = i;
                if (/[A-Z]/.test(parts[i])) {
                    parts.splice(i, 1)[0].split(/([A-Z][a-z]*)/).filter(function(p) {
                        return p !== "";
                    }).forEach(function(p) {
                        parts.splice(j, 0, p);
                        j++;
                    });
                }
            }
        }

        return parts;
    }

    function camelize(str) {
        var parts = partify(str);

        return parts.map(function(p) {
            return p.substr(0, 1).toUpperCase() + p.substr(1, p.length);
        }).join("");
    }

    function removeStringEquivalents(str, equivs) {
        var forms = [
                function(s) {
                    return s.toLowerCase();
                },
                function(s) {
                    return s.toUpperCase();
                },
                function(s) {
                    return s.substr(0, 1).toUpperCase() + s.substr(1, s.length);
                }
            ],
            equivalences = [],
            r,
            i;

        equivs.forEach(function(e) {
            forms.forEach(function(f) {
                equivalences.push(f(e));
            });
        });

        for (i = 0; i < equivalences.length; i++) {
            r = new RegExp("[\-_ ]" + equivalences[i], "g");
            str = str.replace(r, "");
        }

        return str;
    }

    function stripCommonFixes(str) {
        var fixes = ["id","fk","pk"];

        fixes.forEach(function(f) {
            str = str.replace(new RegExp("(?: |\-|_|^)" + f + "(?: |\-|_|$)", "g"), "");
        });

        return str;
    }

    function buildConstraintName(alias, localTable, foreignTable, cardinality, localField, foreignField, count) {
        var name,
            temp;

        if (localTable === "ExternalEntity") {
            console.log(localTable + " for " + localField + " refcount = " + count + ", cardinality: " + cardinality);
        }

        if (cardinality === "single") {
            // self referencing
            if (localTable === foreignTable) {
                name = camelize(stripCommonFixes(localField));
            } else {
                if (count === 1) {
                    name = foreignTable;
                } else if (count > 1) {
                    name = stripCommonFixes(localField);
                }
            }

            name = singularize(camelize(name));
        } else if (cardinality === "many") {
            // self-referencing
            if (localTable === foreignTable) {
                name = pluralize(camelize(foreignTable));
            } else {
                if (count === 1) {
                    name = pluralize(camelize(foreignTable.replace(localTable,"")));
                } else if (count > 1) {
                    name = pluralize(camelize(foreignTable)) + camelize(stripCommonFixes(foreignField));
                }
            }
        }

        return name;
    }

    parseTables(lines);
    parseConstraints(lines);
    fs.writeFileSync("src/scripts/build-graph/build/graph.json", JSON.stringify(graph), "utf8");
};
