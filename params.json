{"name":"relational-json","tagline":"","body":"# Relational JSON\r\nTakes a JSON data structure and converts it into a database-like module allowing easy CRUD operations on immutable & relational objects (*no data duplication*).\r\n\r\n#### Motivation, or why use relational-json\r\nWhen building web applications, sooner or later you end up consuming data from various APIs. These data sources typically manage relational data from a SQL database.\r\n\r\nA common problem, in the front-end, arises when you update a relation. Whether you are changing the relation target (*i.e. changing the FK value*) or changing the relations' data itself, somehow you have to make sure that everything updates properly throughout your data store(s).\r\n\r\nA well known solution to this issue is Dan Abramov's [Normalizr library](https://github.com/gaearon/normalizr). Relational-JSON attempts to solve the same issue by making all data dynamically relational. It also provides immutability for better predictability.\r\nBoth these libraries target the same issue, but use a different approach. If relational-json doesn't float your boat, I strongly recommend trying normalizr as an alternative.\r\n\r\n## Installation\r\n```\r\nnpm install relational-json --save\r\n```\r\n\r\n## Essential concepts\r\nRelational-JSON builds a **dynamic** data store of objects, to achieve this it makes heavy usage of object `Getters/Setters` from ES5 (*Hint: only IE9+ is supported, this cannot be shimmed*). \r\n\r\nEach object created by relational-json is prototype-less, it doesn't inherit any properties or methods. This allows us to make a predictable inheritance chain with predictable own-properties and enumerable properties.\r\n\r\nThere are two types of relations supported by relational-json:\r\n- **Extension** (*inheritance*). Parent's become childrens' prototypes along the inheritance chain.\r\n- **Aggregation** (*one-to-one or one-to-many*).\r\n\r\n## IMPORTANT limitation\r\nBecause relational-json makes heavy usage of `Getters/Setters` you won't be able to use recursion for traversing nested structures. Due to the dynamic nature of your relations, a recursive operation will loop eternally because each nested object could also refer to it's containing object, which starts the whole loop over every time.\r\n\r\nIf you need to work with a chunk of data with recursive functions, we suggest you map the chunk you need, and use that map.\r\n\r\n## JSON data schema\r\nThe expected JSON structure is a collection of \"Table\" objects, with the following generic structure:\r\n```js\r\n// generic table structure. \"fields\" & \"primary\" are mandatory.\r\n{\r\n  \"TableName\": {\r\n    \"fields\": {}, // fields or columns of the data table\r\n    \"primary\": \"\", // primary field of the table\r\n    \"aggregates\": [], // relations to other tables\r\n    \"extends\": \"\", // parent table (inheritance) \r\n    \"extendedBy\": [] // child tables (inheritance)\r\n  }\r\n}\r\n```\r\n\r\n### Tables\r\nYour JSON data structure can contain any amount of tables. Each table must respect the following points:\r\n- Table names must be unique.\r\n- Tables must have a **primary** property (*the name of the primary field of the table*)\r\n- Tables must have **fields**, which minimally contains the primary field of the table.\r\n\r\n```js\r\n// minimal table schema\r\n{\r\n  \"TableName\": {\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      }\r\n    },\r\n    \"primary\": \"id\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n### Table fields\r\nEvery Table in your relational structure must have fields. Fields describe the nature of your data and the constraints that relational-json will enforce during POST and PUT operations.\r\nFields have the following properties:\r\n- **dataType**: the primitive type of your data. Supported types are:\r\n  - string\r\n  - date (*ISO format*)\r\n  - time (*ISO format, no timezone*)\r\n  - datetime (*ISO format, no timezone*)\r\n  - integer\r\n  - float\r\n  - boolean (*true, false, 0, 1*)\r\n- **allowNull**: whether the value can be set to *null* or not.\r\n- **defaultValue**: the default value to use on a POST operation, if no value is provided.\r\n  \r\n```js\r\n{\r\n  \"TableName\": {\r\n    \"primary\": \"id\",\r\n    // adding fields information to your table\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      },\r\n      \"title\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"string\"\r\n      },\r\n      \"is_active\": {\r\n        \"allowNull\": false,\r\n        \"defaultValue\": 1,\r\n        \"dataType\": \"boolean\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Table extends\r\nTables can extend a parent table, which means that each object from the child table will have a prototype object from the parent table. \r\nThe **extends** property is an object containing the following properties:\r\n- **table**: the parent table name\r\n- **local**: the local field (*child table*) used for the relation. (*equivalent to a foreign key (FK) field in SQL*). This must be the table's primary key (PK).\r\n- **foreign**: the parent table field used for the relation. *usually the PK of the foreign table*. This must be the table's primary key (PK).\r\n\r\nWhen a table extends another, the child object cannot exist without the parent object. When you POST on a child table, relational-json will try two things:\r\n- If the parent table contains an entry with a PK value equal to the new child's PK value, that parent becomes the child's prototype.\r\n- If no existing parent is found for a given PK value, the parent is created using the provided data. (*This means that you must provide all required fields for all ancestors of a table on POST*)\r\n\r\n```js\r\n{\r\n  \"TableA\": {\r\n    \"primary\": \"id\",\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      },\r\n      \"name\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"string\"\r\n      }\r\n    }\r\n  },\r\n  \"TableB\": {\r\n    \"primary\": \"id\",\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      },\r\n      \"job_title\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"string\"\r\n      }\r\n    },\r\n    // extending your table to inherit from TableA\r\n    \"extends\": {\r\n      \"table\": \"TableA\",\r\n      \"local\": \"id\", // refers to TableB.id\r\n      \"foreign\": \"id\" // refers to TableA.id\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Table extendedBy\r\nA table can be extended by child tables, this is essentially the same as *extends*, but from the parent table's point of view. This allows the parent table's objects to refer to their children.\r\nThe `extendedBy` property is an array of objects with the following properties:\r\n- **foreignTable**: the table that is a child of the current table.\r\n- **localField**: local field used for the relation.\r\n- **foreignField**: foreign field used for the relation.\r\n\r\n#### Table extendedBy example\r\nIf we take the previous example, we can add the `extendedBy` property to `TableA`:\r\n```js\r\n{\r\n  \"TableA\": {\r\n    \"primary\": \"id\",\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      },\r\n      \"name\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"string\"\r\n      }\r\n    },\r\n    // added extendedBy information to relate to children\r\n    \"extendedBy\": [\r\n      {\r\n        \"foreignTable\": \"TableB\",\r\n        \"localField\": \"id\",\r\n        \"foreignField\": \"id\"\r\n      }\r\n    ]\r\n  },\r\n  \"TableB\": {\r\n    \"primary\": \"id\",\r\n    \"fields\": {\r\n      \"id\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"integer\"\r\n      },\r\n      \"job_title\": {\r\n        \"allowNull\": false,\r\n        \"dataType\": \"string\"\r\n      }\r\n    },\r\n    \"extends\": {\r\n      \"table\": \"TableA\",\r\n      \"local\": \"id\", // refers to TableB.id\r\n      \"foreign\": \"id\" // refers to TableA.id\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Table aggregates\r\nTables aggregate data from other tables, this is the most common form of relation between tables. It replicates the `one-to-many` or `one-to-one` relations found in database relations. \r\n\r\n#### one-to-one\r\nOne-to-one relations are represented as nested objects.\r\n\r\n#### one-to-many\r\nOne-to-many relations are represented as an array of objects.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}