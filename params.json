{
  "name": "relational-json",
  "tagline": "",
  "body": "**relational-json** makes working with complex data simpler than ever.\r\n\r\n# Getting started\r\n### Install relational-json\r\n\r\n`npm install relational-json --save`\r\n\r\n### Require\r\nRelational-json is quite straight-forward. You require relational-json into your source:\r\n\r\n`var rJSON = require(\"relational-json\");`\r\n\r\nand you create a db based on a schema you provide:\r\n\r\n`var db = rJSON(schema);`\r\n\r\n----------------------------\r\n\r\n### How it works\r\nRelational-json wraps your primitive data (*strings, numbers, booleans*) in an immutable & relational structure. The format is just like JSON, except your data can reference other parts of your data tree. This is done dynamically, thanks to ES5 object getters & setters.\r\nEach object created inside relational-json is \"pure\", in the sense that it has no native prototype. This allows us to leverage JavaScripts prototypical inheritance in very elegant ways.\r\n\r\nrelational-json is JSON with conscience.\r\n\r\n### Why use it\r\nWhen building web applications you'll be dealing with a wide variety of data and multiple data sources. Managing application state updates can quickly become problematic, especially when certain data branches rely on other branches. When you update a value, you have to make sure the change propagates everywhere. Relational-json makes all of that simpler:\r\n\r\n1. It eliminates data duplication\r\n2. It simplifies data updates (*you only ever need to modify data in 1 place, since there are no duplicates*)\r\n3. It encapsulates your data, data manipulation logic and restricts certain operations (*such as wrong datatype in a given field*)\r\n4. It's extremely portable, since the data uses the well-known JSON syntax.\r\n5. It makes no environment assumptions (*can be used in browser, on node, etc.*)\r\n\r\n## Limitation\r\nBecause of it's referential nature, `JSON.stringify()` does not work as expected. This is due to *infinite nesting*, which makes you\r\njump from prototype to child and back again, infinitely, if you don't control the data traversal.\r\n(*we provide a simple utility, which entirely mitigates the issue*)\r\n\r\nAlso, relational-json is IE9+ compatible, but **cannot be shimmed or polyfilled** for older browsers.\r\n\r\n------------------------------\r\n\r\n## The schema\r\nRelational-json expects a javascript-object schema representing the data tree you wish to use. Below is a full break down of the schema notation:\r\n\r\n```js\r\n{\r\n    tableName: {\r\n        primary: \"field to use as unique identifier. Field must be in fields object.\",\r\n        fields: {\r\n            fieldName: {\r\n                allowNull: \"can the value be set to null (true / false)\",\r\n                dataType: \"datatype of the field (string, integer, float, date, time, datetime, boolean)\",\r\n                defaultValue: \"value to use if none provided at creation time\"\r\n            }\r\n        },\r\n        extends: {\r\n            table: \"tableName that is a parent of this table\",\r\n            localField: \"own field that references parent table\",\r\n            foreignField: \"parent table field that localField is matched with\"\r\n        },\r\n        aggregates: [\r\n            {\r\n                table: \"tableName that is aggregated\",\r\n                alias: \"property alias to use for relation\",\r\n                localField: \"local field used to build aggregate relations\",\r\n                foreignField: \"foreign field used in aggregate relation\",\r\n                cardinality: \"(single / many), a single relation provides a direct relation to another object. A many relation creates an array of objects\"\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\nTable fields can also be written in shorthand. This creates a field that has *no defaultValue* and *cannot be null*:\r\n```\r\ntableName: {\r\n    fields: {\r\n        id: \"integer\",\r\n        name: \"string\"\r\n    }\r\n}\r\n```\r\n\r\n### Schema relations\r\n#### extends\r\nExtends is an **inheritance** pattern. It signifies that a table's rows are the *child* of another table's rows. Concretely, every row object created in this table will use a row object from a parent table as **prototype**.\r\nThe `extends` relationship is also reflected in the parent tables' rows, which will contain a property to the child row. This will allow you to traverse your data trees in both directions (*up ancestors and down descendants*).\r\n\r\n**extends example**\r\n```js\r\nvar schema = {\r\n    Vehicle: {\r\n        primary: \"id\",\r\n        fields: {\r\n            id: \"integer\",\r\n            year: \"integer\",\r\n            maker: { allowNull: true, dataType: \"string\" }\r\n        }\r\n    },\r\n    Car: {\r\n        primary: \"id\",\r\n        fields: {\r\n            id: \"integer\",\r\n            model: \"string\"\r\n        },\r\n        extends: { table: \"Vehicle\", localField: \"id\", foreignField: \"id\" }\r\n    }\r\n};\r\n\r\nvar db = rJSON(schema);\r\n\r\ndb.Car.post({\r\n    id: 1,\r\n    year: 2001,\r\n    maker: \"Toyota\",\r\n    model: \"Camry\"\r\n});\r\n\r\ndb.Car.get(1);\r\n/*  own props\r\n    {\r\n        id: 1,\r\n        model: \"Camry\"\r\n    }\r\n*/\r\n\r\n// prototype props\r\ndb.Car.get(1).year; // 2001\r\ndb.Car.get(1).maker; // \"Toyota\"\r\n\r\ndb.Vehicle.get(1);\r\n/*\r\n{\r\n    id: 1,\r\n    year: 2001,\r\n    maker: \"Toyota\",\r\n    Car: {\r\n        id: 1,\r\n        model: \"Camry\"\r\n    }\r\n}\r\n*/\r\n```\r\n\r\n#### aggregates\r\nThis is a composite relation between tables, not inheritance-based. Concretely, if table A \"aggregates\" table B, rows from table A will have a property pointing to one row (*object*) or many rows (*array*) from table B, based on the relations cardinality.\r\nUnlike `extends`, aggregate does not affect the prototype chain.\r\n\r\n**aggregates example (single)**\r\n```js\r\nvar schema = {\r\n    Vehicle: {\r\n        primary: \"id\",\r\n        fields: {\r\n            id: \"integer\",\r\n            year: \"integer\",\r\n            maker: { allowNull: true, dataType: \"string\" }\r\n        }\r\n    },\r\n    Client: {\r\n        primary: \"id\",\r\n        fields: {\r\n            id: \"integer\",\r\n            name: \"string\",\r\n            vehicle_id: { allowNull: true, dataType: \"integer\" }\r\n        },\r\n        aggregates: [\r\n            { table: \"Vehicle\", alias: \"Vehicle\", localField: \"vehicle_id\", foreignField: \"id\", cardinality: \"single\" }\r\n        ]\r\n    }\r\n};\r\n\r\nvar db = rJSON(schema);\r\n\r\ndb.Vehicle.post({\r\n    id: 1,\r\n    year: 2001,\r\n    maker: \"hyundai\"\r\n});\r\n\r\ndb.Client.post({\r\n    id: 2,\r\n    name: \"bob the builder\",\r\n    vehicle_id: 1\r\n});\r\n\r\ndb.Client.get(2);\r\n/*\r\n{\r\n    id: 2,\r\n    name: \"bob the builder\",\r\n    Vehicle: {\r\n        id: 1,\r\n        year: 2001,\r\n        maker: \"hyundai\"\r\n    }\r\n}\r\n*/\r\n```\r\n\r\n-------------------------------\r\n\r\n<a name=\"Table\"></a>\r\n\r\n## Table : <code>object</code>\r\n**Kind**: global typedef  \r\n**Summary**: Once relational-json parsed your schema, it will return your relational database, which will be a collection of all the Tables in your data.\r\nEach Table uses an internal Dictionary to store, retrieve and manipulate it's data (rows).\r\nTables are essentially the interface through which you manipulate data.  \r\n\r\n* [Table](#Table) : <code>object</code>\r\n    * [.meta](#Table+meta) : <code>object</code>\r\n    * [.get()](#Table+get) ⇒ <code>object</code> &#124; <code>Array.&lt;object&gt;</code>\r\n    * [.post(d)](#Table+post) ⇒ <code>object</code>\r\n    * [.put(d, pkValue)](#Table+put) ⇒ <code>object</code>\r\n    * [.delete(id)](#Table+delete) ⇒ <code>object</code>\r\n\r\n<a name=\"Table+meta\"></a>\r\n\r\n### table.meta : <code>object</code>\r\n**Kind**: instance property of <code>[Table](#Table)</code>  \r\n**Summary**: partial interface into the Table's inner details  \r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | Table's property key in the relational-json database |\r\n| pk | <code>string</code> | name of the Table's primary field |\r\n| primary | <code>string</code> | alias of Table.meta.pk |\r\n| aliasMap | <code>object</code> | hashmap of the the table's rows' properties pointing to other tables in the relational-json database |\r\n| ownRequiredFields | <code>Array.&lt;string&gt;</code> | list of all own required fields, which must have a value at all times |\r\n| allRequiredFields | <code>Array.&lt;string&gt;</code> | list of all required fields, including own & ancestors' required fields |\r\n\r\n<a name=\"Table+get\"></a>\r\n\r\n### table.get() ⇒ <code>object</code> &#124; <code>Array.&lt;object&gt;</code>\r\n**Kind**: instance method of <code>[Table](#Table)</code>  \r\n**Summary**: returns row data matching the provided arguments on their primary field value  \r\n**Returns**: <code>object</code> &#124; <code>Array.&lt;object&gt;</code> - if no argument is provided, it returns an array of all data within the table.\r\nif 1 argument is provided, it returns that row object\r\nif many arguments are provided, it returns an array containing those row objects  \r\n<a name=\"Table+post\"></a>\r\n\r\n### table.post(d) ⇒ <code>object</code>\r\n**Kind**: instance method of <code>[Table](#Table)</code>  \r\n**Summary**: creates a new row of data  \r\n**Returns**: <code>object</code> - row instance created  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| d | <code>object</code> | data bundle, must contain all required fields |\r\n\r\n<a name=\"Table+put\"></a>\r\n\r\n### table.put(d, pkValue) ⇒ <code>object</code>\r\n**Kind**: instance method of <code>[Table](#Table)</code>  \r\n**Summary**: modifies a data row, by re-creating the row merged with the new data  \r\n**Returns**: <code>object</code> - newly created row  \r\n\r\n| Param | Type | Default | Description |\r\n| --- | --- | --- | --- |\r\n| d | <code>object</code> |  | field:value object of data to modify |\r\n| pkValue | <code>\\*</code> | <code>d.primary</code> | primary value to find row to modify |\r\n\r\n<a name=\"Table+delete\"></a>\r\n\r\n### table.delete(id) ⇒ <code>object</code>\r\n**Kind**: instance method of <code>[Table](#Table)</code>  \r\n**Summary**: recursively deletes the target row and it's children (if any)  \r\n**Returns**: <code>object</code> - deleted row  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| id | <code>\\*</code> | primary field value of row to delete |\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}